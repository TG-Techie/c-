// SECTION lark entry point
//start: (funcdef | classdef | assign_stmt | NEWLINE)*
start: (funcdef | traitdef | classdef | import_dec | stmt | NEWLINE)*

//tokens

TRUE: "True"
FALSE: "False"
NONE: "None"

STRING      : /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING : /(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is

DEC_NUMBER  : /[0-9]\d*/i
HEX_NUMBER  : /0x[\da-f]*/i
OCT_NUMBER  : /0o[0-7]*/i
QUAD_NUMBER : /0q[0-3]*/i
BIN_NUMBER  : /0b[0-1]*/i
FLOAT_NUMBER: /((\d+\.\d*|\.\d+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i

TYPENAME: /_*[A-Z][a-zA-Z_0-9]{2,}/
VARNAME:  /_*[a-z][a-z_0-9]*/ ///_*[a-z][a-zA-Z_0-9]*/

LONGCOMMENT  : /###[^#]*###/
BREAKCOMMENT : /##[^#\n]*##/
LINECOMMENT  : /#[^\n]*/
COMMENT : LONGCOMMENT | LINECOMMENT | BREAKCOMMENT
NEWLINE : ( COMMENT? /\r?\n[\t \f]*/ )+

typelist: (typeident varname (comma typeident varname)*)?  comma?
        | (NEWLINE INDENT)? (typeident varname (comma typeident varname)*)?  (comma | NEWLINE)? (DEDENT|INDENT)?
//arglist: (varname (comma varname)*)? comma?
paramlist: (expr (comma expr)*)? comma?
//comma: "," COMMENT? NEWLINE?
comma: "," NEWLINE?
//comma: "," COMMENT? "\r"? "\n"?

// FIXME: make sure you cannot import <Str>, etc
import_dec  : "import" (import_aliases | "*") NEWLINE
            | "from" ident "import" (import_aliases | "*") NEWLINE
import_aliases  : import_alias ("," import_alias)* ","?
import_alias : (ident ( "as" varname )?) | (typeident ( "as" typename )?)

// statement
stmt: pass_stmt     | del_stmt      | continue_stmt | break_stmt
    | if_stmt       | while_stmt    | count_stmt    | for_stmt
    | return_stmt                   | item_assign_stmt
    | ident_assign_stmt             | expr_stmt

pass_stmt: "pass" NEWLINE
continue_stmt: "continue" NEWLINE
break_stmt: "break" NEWLINE
del_stmt : "del" varname (comma varname)* NEWLINE

expr_stmt: expr NEWLINE

if_stmt : "if" expr stmt_block ("elif" expr stmt_block)* ("else" stmt_block)?

while_stmt : "while" expr stmt_block
for_stmt   : ("for" "each")("foreach") varname "in" expr stmt_block
count_stmt   : "count" (to_pair|from_pair|by_pair)* stmt_block

to_pair   : "to" expr
from_pair : "from" expr
by_pair   : "by" expr

ident_assign_stmt : (expr ".")? ident "=" expr NEWLINE
item_assign_stmt : expr "[" expr "]" "=" expr NEWLINE
return_stmt : "return" expr NEWLINE | "return" NEWLINE

funcdec  : "dec" (get | set)? varname "(" typelist ")" ("returns" typeident)? ";"? NEWLINE?
funcdef  : "def" (get | set)? varname "(" typelist ")" ("returns" typeident)? stmt_block

get: "get"
set: "set"

classdef : "class" typename ("contains" "(" typelist ")")? class_block
         //| "subclass" typename ("from" typeident "with" "(" typelist ")")? class_block
         | "class" typename "subclasses" typeident ("with" "(" typelist ")")? class_block

traitdec : "trait" typename ";"? NEWLINE
traitdef : "trait" typename traitdef_block
traitimpl : "trait" typeident traitimpl_block

// block, ie indented sections fo code
stmt_block  : ":" NEWLINE (INDENT|DEDENT) stmt+ DEDENT
            | ":" stmt

class_block : ":" NEWLINE (INDENT|DEDENT) (funcdef | traitimpl | pass_stmt)+ DEDENT
            | ":" pass_stmt
            //| NEWLINE

traitdef_block : ":" NEWLINE (INDENT|DEDENT) (funcdec | funcdef | traitdec | pass_stmt)+ DEDENT
               | ":" pass_stmt

traitimpl_block : ":" NEWLINE (INDENT|DEDENT) (funcdef | pass_stmt)+ DEDENT
                | ":" pass_stmt

expr: literal       | attr_expr     | item_get_expr | new_expr
    | call_expr     | var_expr      | binop_expr
    | uniop_expr    | "(" expr ")"  | negop_expr
new_expr : typeident "(" paramlist ")"
attr_expr   : expr "." ident
call_expr   : expr "(" paramlist ")" // determine if method or __call__ at model time
var_expr    : ident
item_get_expr : expr "[" expr "]"
uniop_expr  : uniop expr
binop_expr  : expr binop expr
negop_expr  : "-" expr

binop: bitws_binop | arith_binop | compr_binop | logcl_binop
logcl_binop : "is" "not" -> isnot   | "is"  -> is
            | "or"  -> or           | "xor" -> xor
            | "and" -> and

compr_binop : "!=" -> noteq     | "==" -> eq    | ">=" -> grtreq
            | "<=" -> lesseq    | ">" -> gr     | "<" -> ls
            | "not" "in" -> notin   | "in"  -> in

arith_binop : "+" -> add        | "-" -> sub    | "*" -> mul
            | "//" -> floordiv  | "/" -> div    | "%" -> mod
            | "**" -> pow

bitws_binop : "&" -> bwand      | "^" -> bwxor  | "|" -> bwor
            | "<<" -> bwlshift  | ">>" -> bwrshift

uniop : "not" -> not | "~" -> bwnot

typeident   : builtintype | user_type_ident
ident       : varname //("." varname)*  // identifier
typename    : TYPENAME
varname     : VARNAME

user_type_ident : (ident ".")* typename
//builtintype: "Int" -> int | "Bool" -> bool | "Str" -> str
//           | "Float" -> float | "NoneType" -> nonetype
//           | "Regex" ->regex
//           | "SomeType" -> selftype | "Self" -> selftype
//           | "<" typeident ">" -> arrtype
//           | "{" typeident ":" typeident "}" -> maptype

builtintype: "<" typeident ">" -> arrtype
           | "{" typeident ":" typeident "}" -> maptype

literal : number | string | bool | none | arraylitrl | maplitrl

// SECTION postlex declares and ignores
number: integer | float
integer: HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | QUAD_NUMBER | DEC_NUMBER
float: FLOAT_NUMBER
string: STRING | LONG_STRING
//string: single_string | double_string //| ling_single_string | long_double_string
bool: TRUE | FALSE
none: NONE
regex: "/"/^((?:(?:[^?+*{}()[\]\\|]+|\\.|\[(?:\^?\\.|\^[^\\]|[^\\^])(?:[^\]\\]+|\\.)*\]|\((?:\?[:=!]|\?<[=!]|\?>)?(?1)??\)|\(\?(?:R|[+-]?\d+)\))(?:(?:[?+*]|\{\d+(?:,\d*)?\})[?+]?)?|\|)*)$/"/"
arraylitrl: "<" expr ("," expr)* ","? ">"
maplitrl: "{" expr ":" expr ("," expr ":" expr)* ","? "}"

%ignore /[\t \f]+/  // WS
%ignore /\\/ NEWLINE  // LINE_CONT
%ignore COMMENT

// for indenter post processing
%declare INDENT DEDENT
